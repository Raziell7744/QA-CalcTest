#!/usr/bin/perl
## Initially generated by Win32-GuiTest Recorder (v1.03)

## Pragmas/Directives
use strict;
use warnings;

## Imports
use Win32::GuiTest qw/:ALL/;

$Win32::GuiTest::debug = 0;    # Set to "1" to enable debug output.

## Variables/Constants
my $fgWindow = 0;              # Foreground Window

## Main/Core
# Open calculator
system('"C:\Windows\System32\calc.exe"');
sleep(1);

# Focus to calculator window
my @arr;
my @hwnds;
@arr = FindWindowLike( undef, 'Calculator' );

# Reading from input file
my $inputFileName = '.\input.txt';
open( my $inputFile, '<:encoding(UTF-8)', $inputFileName )
  or die "Could not open file '$inputFileName' $!";

# Reading from expected results file
my $expectedResultsFileName = '.\expectedResults.txt';
open( my $expectedResultsFile, '<:encoding(UTF-8)', $expectedResultsFileName )
  or die "Could not open file '$expectedResultsFileName' $!";

my $index      = 1;
my $resultType = 0;    # 0 - None, 1 - Diff All, 2 - Diff Days
my $result = "";

while ( my $row = <$inputFile> ) {
    $resultType = 0;

    # Reset Date Screen - BeforeEach
    # Ctrl + F4 to change to basic
    SendKeys('^{F4}');
    sleep(1);

    # Ctrl + E to change to date calc
    SendKeys('^e');
    sleep(1);

    #TAB to move to choose date mode
    SendKeys('{TAB}');
    select( undef, undef, undef, 1 );

    print "Test Case ", $index, ": ";
    $index++;

    # Input Test Params
    chomp $row;

    for my $char ( split //, $row ) {
        if ( $char eq '#' ) {
            last;
        }
        if ( $char eq ' ' ) {
        }
        elsif ( $char eq 'R' ) {
            SendKeys('{RIG}');    # Right
            select( undef, undef, undef, 1 );
            print "/";
        }
        elsif ( $char eq 'T' ) {
            SendKeys('{TAB}');
            select( undef, undef, undef, 1 );
            print " -> ";
        }
        elsif ( $char eq 'E' ) {
            SendKeys('{ENT}');    # Enter
            select( undef, undef, undef, 1 );
            print " CALC \n";
            @hwnds = GetChildWindows(@arr);
            for (@hwnds) {
                my $text = WMGetText($_);
                if ( $text ne '' ) {
                    if ( $text eq 'Difference (years, months, weeks, days)' ) {
                        $resultType = 1;
                    }
                    elsif ( $text eq 'Difference (days)' ) {
                        $resultType = 2;
                    }
                    elsif ( $resultType eq 1 ) {
                        print "Difference All: ", $text, "\n";
                        $result = $text . " - ";
                        $resultType = 0;
                    }
                    elsif ( $resultType eq 2 ) {
                        print "Difference Days: ", $text, "\n";
                        $result = $result . $text;
                        $resultType = 0;
                    }
                }
            }
            # Need to check if $result = the correct line in $expectedResultsFile
            # This can be done using something like:
            # @expectedLines = <$expectedResultsFile>
            # $lineResult = $expectedLines[$index-1]
            # https://docstore.mik.ua/orelly/perl4/cook/ch08_09.htm
            print "Result: ", $result, "\n"
        }
        else {
            SendKeys("{$char}");
            print $char;
        }
    }

    # Get Output from Window
    # TODO
    # Assert against Expected Results
    # TODO
}

# Close the calculator
SendKeys('%{F4}');

# #reading from data file
# my $inputFileName = '.\data.txt';
# open(my $inputFile, '<:encoding(UTF-8)', $inputFileName)
# 	or die "Could not open file '$inputFileName' $!";

# #my$char;
# my $num;
# while (my $row = <$inputFile>) {
#  	chomp $row;
# 	if ($row eq 'calc'){
# 		SendKeys('{ENT}'); #ENTER
# 		select(undef, undef, undef, 1);
# 	}
# 	elsif($row eq 'tab'){
# 		SendKeys('{TAB}');
# 		select(undef, undef, undef, 1);
# 	}
# 	else
# 	{
# 		for my $char (split //, $row) {
# 			SendKeys("{$char}");
# 		}
# 		#moving right
# 		SendKeys('{RIG}');
# 		select(undef, undef, undef, 1);
# 	}
# }

## Subroutines
